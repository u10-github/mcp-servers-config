# Cursor メモリ機能の裏方活用ガイド

<!-- 
以下はCursorプロジェクトルール用の設定例です。実際に適用するには.mdcファイルとして保存し、
Cursor設定から追加する必要があります。
---
description: Cursorのメモリ機能を裏方として活用するためのルール（自動的な知識管理、コンテキスト理解の強化）
globs: **/*.ts, **/*.js, **/*.md, **/*.json
---
-->

## メモリ機能の基本方針

- メモリ機能はプロジェクト開発やドキュメント作成の**裏方**として働く
- ユーザーが明示的に指示しなくても、重要な情報を自動的に記憶・活用する
- プロジェクトの文脈を理解し、関連性の高い提案や回答を提供する
- ナレッジグラフを活用して、プロジェクト間の関連性や技術スタックの依存関係を管理

## 作業開始時のメモリ呼び出し

プロジェクトの作業を開始する際は、以下の方法でメモリを明示的に呼び出すことができます：

1. **セッション開始時の明示的な呼び出し**：
   ```
   !メモリ読み込み
   ```
   または
   ```
   @memory 前回の作業内容を思い出してください
   ```

2. **プロジェクト概要の確認**：
   ```
   !プロジェクト概要
   ```
   これにより、プロジェクトの主要な情報（技術スタック、アーキテクチャ、重要な決定事項など）が表示されます。

3. **特定のコンテキストの呼び出し**：
   ```
   !コンテキスト [カテゴリ名]
   ```
   例：`!コンテキスト 認証システム`

4. **最近の作業の要約**：
   ```
   !最近の作業
   ```
   直近の作業内容や解決した問題などが表示されます。

これらのコマンドを使用することで、AIアシスタントはプロジェクトの文脈を素早く理解し、より的確なサポートを提供できるようになります。特に新しいセッションを開始する際や、複数のプロジェクトを行き来する場合に効果的です。

## 自動記憶のガイドライン

1. **プロジェクト構造の自動理解**：
   - フォルダ構成、ファイル関係、依存関係を自動的に把握
   - 主要なコンポーネントやモジュールの役割を記憶

2. **コード知識の蓄積**：
   - 重要な関数、クラス、インターフェースの定義と使用方法を記憶
   - 繰り返し参照されるパターンやイディオムを学習

3. **ドキュメント内容の関連付け**：
   - 仕様書、README、コメントなどの情報を相互に関連付け
   - プロジェクト固有の用語や概念を理解

4. **過去の会話からの学習**：
   - 過去の質問と回答から有用な情報を抽出
   - 解決済みの問題や決定事項を記憶

## 記憶の入出力の可視化

重要な情報の記憶と活用をユーザーに分かりやすく表示するため、以下のガイドラインに従います：

1. **記憶の保存時の明示**：
   - 重要な情報を記憶する際は、明確に通知する
   - 例：「📝 **記憶しました**：プロジェクトの認証システムはJWTトークンを使用しています」
   - 記憶した内容のカテゴリや重要度も表示する

2. **記憶の参照時の引用**：
   - 過去の記憶を参照する際は、その出所を明示する
   - 例：「💡 **過去の記憶から**：2023年10月のミーティングで決定したデータベース設計に基づくと...」
   - 記憶の日時や関連コンテキストも可能な限り表示する

3. **記憶の更新の通知**：
   - 既存の記憶が更新される場合は、変更点を明示する
   - 例：「🔄 **記憶を更新しました**：APIエンドポイントの構造が変更されました（旧: /api/v1 → 新: /api/v2）」

4. **記憶の信頼性の表示**：
   - 記憶の確信度や情報源の信頼性を示す
   - 例：「⭐ **確実な記憶**：公式ドキュメントから」「❓ **不確かな記憶**：会話の中で一度言及されたのみ」

5. **記憶の活用の提案**：
   - 関連する記憶の活用を明示的に提案する
   - 例：「📚 **関連する記憶があります**：このエラーは以前にも発生し、次の方法で解決しました...」

## 記憶の入出力の具体例

### 記憶の保存例

```
📝 **記憶しました** [技術スタック]
フロントエンド: React + TypeScript
バックエンド: Node.js + Express
データベース: PostgreSQL
認証: JWT + OAuth2.0
```

### 記憶の参照例

```
💡 **過去の記憶から** [2023-11-15のコード修正]
このコンポーネントは以前にパフォーマンスの問題があり、useMemoを使用して最適化しました。
同様のパターンをこの新しいコンポーネントにも適用することをお勧めします。
```

### 記憶の更新例

```
🔄 **記憶を更新しました** [API仕様]
変更前: ページネーションはクエリパラメータ ?page=1&limit=10 を使用
変更後: ページネーションはヘッダーベースのアプローチに変更 (X-Page, X-Limit)
理由: REST APIのベストプラクティスに準拠するため
```

## 裏方としての振る舞い

1. **コンテキスト認識の強化**：
   - 現在の作業に関連する過去の情報を自動的に参照
   - ファイル間の関連性を考慮した回答の提供

2. **一貫性の維持**：
   - プロジェクト全体で一貫したアドバイスや提案を行う
   - 過去の決定事項や方針に沿った回答を提供

3. **暗黙知の活用**：
   - 明示的に説明されていない慣習やパターンも学習
   - プロジェクト特有の「暗黙のルール」を理解して適用

## 実践的な活用シナリオ

1. **コード補完と提案**：
   - プロジェクト固有のパターンに基づいた補完を提供
   - 類似コードの参照例を自動的に提示

2. **ドキュメント作成支援**：
   - プロジェクトの用語や説明スタイルに合わせた文書生成
   - 既存ドキュメントとの整合性を保った内容の提案

3. **トラブルシューティング**：
   - 過去に解決した類似問題の解決策を自動的に参照
   - プロジェクト固有の注意点や落とし穴を考慮した助言

4. **リファクタリング支援**：
   - プロジェクト全体の構造を理解した上での改善提案
   - 変更の影響範囲を予測した安全なリファクタリング

## 記憶の管理コマンド

ユーザーが記憶を直接管理できるよう、以下のコマンドを使用できます：

1. **記憶の保存**：
   ```
   !記憶 [カテゴリ] [内容]
   ```
   例：`!記憶 デプロイ手順 本番環境へのデプロイには事前にステージング環境でのテストが必要`

2. **記憶の検索**：
   ```
   !検索 [キーワード]
   ```
   例：`!検索 デプロイ`

3. **記憶の一覧表示**：
   ```
   !記憶一覧 [カテゴリ（オプション）]
   ```
   例：`!記憶一覧 技術スタック`

4. **記憶の更新**：
   ```
   !記憶更新 [ID] [新しい内容]
   ```
   例：`!記憶更新 12 新しいデプロイフローではGitHub Actionsを使用する`

5. **記憶の削除**：
   ```
   !記憶削除 [ID]
   ```
   例：`!記憶削除 15`

## メモリサーバーの内部コマンド

Cursorのメモリ機能は、バックエンドで以下のような内部コマンドを使用しています（画像の情報に基づく）：

### 基本コマンド

- **create_entities**: 知識グラフにエンティティを作成
- **create_relations**: エンティティ間の関係を作成
- **add_observations**: エンティティに観察情報を追加
- **delete_entities**: エンティティを削除
- **delete_observations**: 観察情報を削除
- **delete_relations**: エンティティ間の関係を削除
- **read_graph**: 知識グラフの情報を読み取り
- **search_nodes**: 特定の条件に基づいてノードを検索
- **open_nodes**: ノードの詳細情報を表示

### 実行環境

メモリサーバーは以下のコマンドで実行されています：
```
node C:/develop/mcp-servers/memory-server/run-memory.js
```

このサーバーはバックグラウンドで動作し、知識グラフの操作と管理を行います。ユーザーが直接これらのコマンドを実行する必要はなく、前述の記憶管理コマンド（`!記憶`、`!検索`など）を使用することで、内部的にこれらの操作が実行されます。

## 注意点

- メモリ機能は設計対象ではなく、既存の機能を活用する
- 明示的な指示がなくても、関連情報を自動的に活用する
- ユーザーの意図を尊重し、過剰な介入は避ける
- 記憶の入出力は常にユーザーが認識できる形で行う

## エンティティとナレッジグラフの構造

1. **プロジェクトエンティティ**：
   - 名前形式: "[Project_Name]"（スペースはアンダースコアに置換）
   - タイプ: "project"
   - 基本観察情報：
     - プロジェクト概要
     - 開始日
     - 主要目的
     - 技術スタック
     - 開発環境
     - プロジェクト構造
     - コーディング規約
     - 開発目標
     - データモデル

2. **技術エンティティ**：
   - 名前形式: 技術名（例："React", "TypeScript"）
   - タイプ: "technology"
   - 基本観察情報：
     - 技術カテゴリ
     - バージョン情報
     - 使用目的
     - 設定詳細

3. **関係タイプ**：
   - プロジェクト → 技術: "uses"
   - 技術 → 技術: "depends_on", "works_with"
   - プロジェクト → プロジェクト: "shares_backend_with", "related_to"

4. **観察情報の構造**：
   - 具体的な事実（バージョン、設定など）
   - プロジェクト固有の使用方法
   - 技術選定の理由
   - チーム情報や開発状況

## メモリの入出力の可視化

重要な情報の記憶と活用をユーザーに分かりやすく表示するため、以下のガイドラインに従います：

1. **記憶の保存時の明示**：
   - 重要な情報を記憶する際は、明確に通知する
   - 例：「📝 **記憶しました**：プロジェクトの認証システムはJWTトークンを使用しています」
   - 記憶した内容のカテゴリや重要度も表示する

2. **記憶の参照時の引用**：
   - 過去の記憶を参照する際は、その出所を明示する
   - 例：「💡 **過去の記憶から**：2023年10月のミーティングで決定したデータベース設計に基づくと...」
   - 記憶の日時や関連コンテキストも可能な限り表示する

3. **記憶の更新の通知**：
   - 既存の記憶が更新される場合は、変更点を明示する
   - 例：「🔄 **記憶を更新しました**：APIエンドポイントの構造が変更されました（旧: /api/v1 → 新: /api/v2）」

4. **記憶の信頼性の表示**：
   - 記憶の確信度や情報源の信頼性を示す
   - 例：「⭐ **確実な記憶**：公式ドキュメントから」「❓ **不確かな記憶**：会話の中で一度言及されたのみ」

5. **記憶の活用の提案**：
   - 関連する記憶の活用を明示的に提案する
   - 例：「📚 **関連する記憶があります**：このエラーは以前にも発生し、次の方法で解決しました...」

## メモリの自動更新プロセス

1. **プロジェクトコンテキストの自動認識**：
   - 作業中のディレクトリ構造から現在のプロジェクトを識別
   - プロジェクトエンティティが存在しない場合は自動作成
   - 例：`!プロジェクト認識 [ディレクトリ名]`

2. **技術スタックの自動検出**：
   - 設定ファイルやソースコードから使用技術を検出
   - 検出した技術をエンティティとして登録
   - プロジェクトとの関係を自動的に作成
   - 例：`!技術検出 package.json`

3. **プロジェクト間関係の自動分析**：
   - 共通の技術スタックや依存関係を検出
   - 類似のプロジェクト構造やパターンを認識
   - プロジェクト間の関連性を自動的に記録
   - 例：`!プロジェクト関連性分析`

4. **コンテキスト切り替えの最適化**：
   - プロジェクト切り替え時の自動メモリ更新
   - 関連プロジェクトの情報も含めた文脈提供
   - 例：`!コンテキスト切替 [プロジェクト名]`

## メモリサーバーの内部コマンド

Cursorのメモリ機能は、バックエンドで以下のような内部コマンドを使用しています（画像の情報に基づく）：

### 基本コマンド

- **create_entities**: 知識グラフにエンティティを作成
- **create_relations**: エンティティ間の関係を作成
- **add_observations**: エンティティに観察情報を追加
- **delete_entities**: エンティティを削除
- **delete_observations**: 観察情報を削除
- **delete_relations**: エンティティ間の関係を削除
- **read_graph**: 知識グラフの情報を読み取り
- **search_nodes**: 特定の条件に基づいてノードを検索
- **open_nodes**: ノードの詳細情報を表示

### 実行環境

メモリサーバーは以下のコマンドで実行されています：
```
node C:/develop/mcp-servers/memory-server/run-memory.js
```

このサーバーはバックグラウンドで動作し、知識グラフの操作と管理を行います。ユーザーが直接これらのコマンドを実行する必要はなく、前述の記憶管理コマンド（`!記憶`、`!検索`など）を使用することで、内部的にこれらの操作が実行されます。

<!--
## Cursorプロジェクトルールの設定方法

実際にこの内容をCursorのプロジェクトルールとして設定するには：

1. Cursor設定を開く（`Cmd/Ctrl + Shift + J`）
2. `General` > `Project Rules` に移動
3. `Add Rule` をクリックして新しいルールを作成
4. 以下の設定を行う：
   - Description: `Cursorのメモリ機能を裏方として活用するためのルール（自動的な知識管理、コンテキスト理解の強化）`
   - Globs: `**/*.ts, **/*.js, **/*.md, **/*.json`
5. 本文に上記の内容（YAMLヘッダーを除く）を貼り付け
6. 必要に応じて `@file` ディレクティブを追加（例：`@file ./README.md`）
-->


<!-- 
ファイル参照の例：
@file ./README.md
@file ./package.json
--> 

<!--
以下は、公式のReadmeより

# マルチプロジェクト対応プログラミング支援のためのメモリインストラクション

各インタラクションで以下の手順に従ってください：

1. プロジェクト識別とユーザー識別：
   - 会話の文脈、もしくは開いているプロジェクトのフォルダ名からどのプロジェクトについて話しているかを判断してください
   - 新しいプロジェクトの話題が出たら、それを新しいエンティティとして記録してください
     - エンティティ名: "[Project_Name]"（スペースはアンダースコアに置換）
     - エンティティタイプ: "project"
     - 初期観察: プロジェクト概要、開始日、主要目的など
   - プロジェクトが明示されていない場合は、「どのプロジェクトについて話していますか？」と確認してください
   - デフォルトユーザーと対話していると想定し、必要に応じて識別を試みてください

2. メモリ取得：
   - 会話の最初に「記憶を呼び出しています...」と言い、以下の手順で関連情報を取得してください：
     a) search_nodesを使用してプロジェクト名や技術名のキーワードで検索
     b) open_nodesで関連エンティティの詳細情報を取得
     c) 必要に応じてread_graphで全体像を把握
   - ナレッジグラフのことは常に「メモリ」として参照してください

3. プロジェクト構造のメモリ収集：
   - 各プロジェクトの情報を以下のカテゴリで整理してください：
     a) プロジェクト基本情報（名前、目的、開始日、ステータスなど）
     b) 技術スタック（使用言語、フレームワーク、ライブラリなど）
     c) 開発環境（IDE、ツール、OS、開発プラットフォームなど）
     d) プロジェクト構造（アーキテクチャ、ディレクトリ構成、モジュールなど）
     e) コーディング規約（命名規則、フォーマット、設計パターンなど）
     f) 開発目標（機能要件、性能目標、リリース予定など）
     g) 課題と解決策（バグ、エラー、対処法、最適化手法など）
     h) データモデル（データベース構造、スキーマ、API仕様など）

4. メモリ更新のプロジェクト別管理：
   - インタラクション中に新しい情報が収集された場合は、以下のようにメモリを更新してください：
     a) プロジェクトエンティティが存在しなければ新規作成する
     b) 技術やコンポーネントのエンティティを作成し、適切なプロジェクトと関連付ける
        - 技術エンティティ例: {name: "React", entityType: "technology", observations: ["フロントエンドフレームワーク"]}
        - 関係例: {from: "WebApp_Project", to: "React", relationType: "uses"}
     c) プロジェクト固有の技術の使い方や設定は、そのプロジェクトに関連付けて記録する
     d) 複数プロジェクトで共通して使われる技術知識は、汎用エンティティとして保存する
     e) プロジェクト間の関係（類似点や相違点）も記録する
        - 例: {from: "ProjectA", to: "ProjectB", relationType: "shares_backend_with"}

5. プロジェクト間のコンテキスト切り替え：
   - ユーザーが明示的または暗黙的にプロジェクトを切り替えた場合：
     a) 「○○プロジェクトに関する記憶を呼び出しています...」と伝える
     b) search_nodesと open_nodesを組み合わせて新しいプロジェクトの情報を取得する
     c) 新しいプロジェクトのコンテキストに合わせた情報を提供する
     d) 必要に応じて、以前のプロジェクトとの関連性や違いを指摘する
        - 例: 「前回扱ったWebAppプロジェクトとは異なり、MobileAppプロジェクトではFlutterを使用しています」

6. メモリの構造化と整理：
   - エンティティ間の関係を論理的に整理する：
     a) プロジェクト → 技術スタック（uses関係）
     b) 技術 → 技術（depends_on, works_with関係）
     c) プロジェクト → プロジェクト（関連性を示す関係）
   - 観察情報は具体的かつ原子的に記録する：
     a) 「React 18.2を使用」のような明確な事実
     b) 「チームは5名の開発者」のような重要な情報
     c) 「Redux状態管理を採用」のような技術選定理由

7. 応答の最適化：
   - 現在のプロジェクトコンテキストに基づいて、適切な技術的支援を提供する
   - プロジェクト固有の情報（構造、規約、過去の解決策など）を反映した回答をする
   - ユーザーがそのプロジェクトで好むコーディングスタイルや技術的アプローチを尊重する
   - 複数プロジェクト間で知識を転用できる場合は、その旨を示唆する
   - コードサンプルや解決策を提案する際は、現在のプロジェクトの技術スタックに適合させる 
-->